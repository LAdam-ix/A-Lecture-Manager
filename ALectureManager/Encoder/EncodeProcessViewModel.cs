using System;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations.Schema;
using System.IO;
using System.Threading.Tasks;
using Avalonia.Controls.ApplicationLifetimes;
using CommunityToolkit.Mvvm.Input;
using HanumanInstitute.FFmpeg;

namespace ALectureManager.Encoder;

public partial class EncodeProcessViewModel : ViewModelBase
{
    #region AvaloniaAutoGeneratedProps

    [ObservableProperty] private string _pauseText;


    #endregion

    #region AvaloniaStaff

    public ObservableCollection<CodecOption> CodecOptions { get; set; }
    public RelayCommand Start { get; }
    public RelayCommand DeleteThis { get; }
    public RelayCommand PausePlay { get; }
    public RelayCommand CancelThis { get; }
    public RelayCommand<string> ShowOpenFile { get; }

    private event Action<EncodeProcessViewModel>? DeleteRequested;

    #endregion

    public bool IsRunning => _encodingTask is { Status: TaskStatus.Running };
    public EncoderProcessData Data { get; init; }

    private readonly EncoderSettingsViewModel _settings;
    private readonly IMediaEncoder _encoder;
    private IProcessWorkerEncoder? _worker;
    private Task? _encodingTask;

    private ProcessOptionsEncoder _encoderOptions;


    public EncodeProcessViewModel(
        EncoderSettingsViewModel settings,
        IMediaEncoder encoder,
        IEnumerable<Action<EncodeProcessViewModel>> deleteHandlers,
        EncoderProcessData processData)
    {
        _encoder = encoder;
        _settings = settings;
        foreach (var handler in deleteHandlers)
        {
            DeleteRequested += handler;
        }

        CodecOptions = _settings.CodecOptions;
        Data = processData;
        Data.CodecOption = Data.CodecOption ?? _settings.DefaultCodecOption;
        if (Data.InputPath != "" && Data.OutputPath == "")
        {
            Data.OutputPath = Utils.GetAutoOutputPath(Data.InputPath);
        }

        PauseText = Data.Paused ? "Continue" : "Pause";

        Start = new RelayCommand(StartExecute);
        DeleteThis = new RelayCommand(DeleteThisExecute);
        PausePlay = new RelayCommand(PausePlayExecute);
        CancelThis = new RelayCommand(CancelThisExecute);
        ShowOpenFile = new RelayCommand<string>(ShowOpenFileExecute);

        _encoderOptions = new ProcessOptionsEncoder(ProcessDisplayMode.ErrorOnly) { ResumePos = Data.ResumeFrame };

        if (Data is { Started: true, Paused: false })
        {
            StartExecute();
        }
    }


    private void StartExecute()
    {
        if (!Validate())
        {
            return;
        }

        _encodingTask = Task.Run(Run);
        Data.Started = true;
    }

    private void Run()
    {
        if (Data.Name == ""){
        Data.Name = System.IO.Path.GetFileName(Data.InputPath);
        }
        var fileInfo = _encoder.EncodeFFmpeg
        (source: Data.InputPath,
            destination: Data.OutputPath,
            videoCodec: Data.CodecOption?.VideoCodec,
            audioCodec: Data.CodecOption?.AudioCodec,
            encodeArgs: Data.CodecOption?.AdditionalArguments,
            _encoderOptions, //[ProcessOptionsEncoder? options = null]
            HandleWorkerStart);


        switch (fileInfo)
        {
            case CompletionStatus.Success:
                Data.Finished = true;
                break;
            case CompletionStatus.Cancelled:
                Data.ResumeFrame += Data.Progress.Frame;
                break;
            default:
                Data.Started = false;
                break;
        }
    }

    private void HandleWorkerStart(object sender, ProcessStartedEventArgs e)
    {
        _worker = (IProcessWorkerEncoder)e.ProcessWorker;
        _worker.ProgressReceived += HandleProgressReceived;
    }

    private void HandleProgressReceived(object sender, ProgressReceivedEventArgs e)
    {
        var s = (IProcessWorkerEncoder)sender;
        Data.TotalFrames = s.FileInfo is FileInfoFFmpeg fi ? fi.FrameCount : 0;
        Data.ProgressBarMax = Data.TotalFrames;
        var progress = (ProgressStatusFFmpeg)e.Progress;
        Data.ProgressBarValue = progress.Frame + Data.ResumeFrame;
        Data.Progress.Update(progress);
    }
    
    private void DeleteThisExecute()
    {
        _worker?.Cancel();
        DeleteRequested?.Invoke(this);
    }

    public void Pause()
    {
        if (Data.Paused || _worker == null)
        {
            return;
        }

        _worker.Cancel();
    }
    // this is broken because the resume from FFMpeg Library don't works
    private async void PausePlayExecute()
    {
        if (Data.Paused)
        {
            _encoderOptions.ResumePos = Data.ResumeFrame;
            StartExecute();
            PauseText = "Pause";
        }
        else
        {

            Pause();
            if (_encodingTask != null)
            {
                await _encodingTask;
            }
            PauseText = "Continue";
        }

        Data.Paused = !Data.Paused;
    }

    private void CancelThisExecute()
    {
        Pause();
        Data.Started = false;
        _worker = null;
    }


    private bool Validate()
    {
        return (
            !string.IsNullOrEmpty(Data.InputPath)
            && File.Exists(Data.InputPath)
            && !string.IsNullOrEmpty(Data.OutputPath)
            && Utils.TryGetDirectory(Data.InputPath) != null
            && Utils.TryGetDirectory(Data.OutputPath) != null
        );
    }

    private async void ShowOpenFileExecute(string? parameter)
    {
        var filePath = await Utils.OpenFileExplorer();

        if (filePath == null) return;
        switch (parameter)
        {
            case "Output":
                Data.OutputPath = filePath;
                break;
            case "Input":
                Data.InputPath = filePath;
                if (Data.OutputPath == "")
                {
                    Data.OutputPath = Utils.GetAutoOutputPath(filePath);
                }

                break;
        }
    }
}