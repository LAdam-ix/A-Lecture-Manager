using System.Collections.ObjectModel;
using System.IO;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.Input;
using HanumanInstitute.FFmpeg;


namespace ALectureManager.Encoder;

public partial class EncodeProcessViewModel : ViewModelBase
{
    private bool DUMMY = false;
    private bool DUMMY_TASK = false;


    #region AvaloniaAutoGeneratedProps

    [ObservableProperty] private string _pauseText;


    #endregion

    #region AvaloniaStaff

    public ObservableCollection<CodecOption> CodecOptions { get; set; }
    public RelayCommand Start { get; }
    public RelayCommand DeleteThis { get; }
    public RelayCommand PausePlay { get; }
    public RelayCommand CancelThis { get; }
    public RelayCommand<string> ShowOpenFile { get; }

    private event Action<EncodeProcessViewModel>? DeleteRequested;

    #endregion
    // the RunToCompletion is only for Dummy mode normaly it will be Running.
    public bool IsRunning => EncodingTask is { Status: TaskStatus.Running or TaskStatus.RanToCompletion };
    public EncoderProcessData Data { get; init; }
    private readonly EncoderSettingsViewModel _settings;
    private readonly IMediaEncoder _encoder;
    private IProcessWorkerEncoder? _worker;
    public Task? EncodingTask { get; private set; }

    private ProcessOptionsEncoder _encoderOptions;


    public EncodeProcessViewModel(
        EncoderSettingsViewModel settings,
        IMediaEncoder encoder,
        IEnumerable<Action<EncodeProcessViewModel>> deleteHandlers,
        EncoderProcessData processData)
    {
        _encoder = encoder;
        _settings = settings;
        foreach (var handler in deleteHandlers)
        {
            DeleteRequested += handler;
        }

        CodecOptions = _settings.CodecOptions;
        Data = processData;
        Data.CodecOption = Data.CodecOption ?? _settings.DefaultCodecOption;
        if (Data.InputPath != "" && Data.OutputPath == "")
        {
            Data.OutputPath = Utils.GetAutoOutputPath(Data.InputPath);
        }

        PauseText = Data.Paused ? "Continue" : "Pause";

        Start = new RelayCommand(StartExecute);
        DeleteThis = new RelayCommand(DeleteThisExecute);
        PausePlay = new RelayCommand(PausePlayExecute);
        CancelThis = new RelayCommand(CancelThisExecute);
        ShowOpenFile = new RelayCommand<string>(ShowOpenFileExecute);

        _encoderOptions = new ProcessOptionsEncoder(ProcessDisplayMode.ErrorOnly) { ResumePos = Data.ResumeFrame };

        if (Data is { Started: true, Paused: false, Finished: false })
        {
            StartExecute();
        }
    }


    private void StartExecute()
    {
        if (!Validate())
        {
            // probably could set this up to check input and output path separately
            // but primary use will be to have output autogenerated so when somthing 
            // go wrong with this it will be fault of both paths
            // also if you try this in Rider it is higly possible to get this error
            // even if the files exist because the of the Rider weird environment
            Utils.GetInfoBox("Error", "Input or Output Path is invalid");
            return;
        }
        EncodingTask = Task.Run(Run);
    }

    private async void Run()
    {
        if (Data.Name == "")
        {
            Data.Name = System.IO.Path.GetFileName(Data.InputPath);
        }
        #region DUMMY_RUN

        if (DUMMY)
        {
            DUMMY_TASK = true;
            Data.Started = true;
            var stopTime = DateTime.Now.AddSeconds(30); // Run for half a minute
            EncodingTask = Task.Delay(1000);
            Data.ProgressBarMax = 2700;
            while (DateTime.Now < stopTime && DUMMY_TASK)
            {
                Data.Frame++;
                Data.ProgressBarValue = Data.Frame;
                Data.Speed++;
                Data.Fps = Data.Frame - Data.Speed;
                Data.Time += TimeSpan.FromSeconds(1);
                Data.Status = Data.Speed.ToString() + "%";
                await Task.Delay(10);
            }

            var DUMMYINFO = CompletionStatus.Success;
            switch (DUMMYINFO)
            {
                case CompletionStatus.Success:
                    Data.Finished = true;
                    break;
                case CompletionStatus.Cancelled:
                    Data.ResumeFrame += Data.Frame;
                    break;
                case CompletionStatus.Failed:
                    Data.Started = false;
                    Utils.GetInfoBox("FFMpeg Error", _worker == null ? "Unknown Error" : _worker.Output);

                    break;
                default:
                    Data.Started = false;
                    break;
            }
            return;
        }
        #endregion

        var fileInfo = _encoder.EncodeFFmpeg
        (source: Data.InputPath,
            destination: Data.OutputPath,
            videoCodec: Data.CodecOption?.VideoCodec,
            audioCodec: Data.CodecOption?.AudioCodec,
            encodeArgs: Data.CodecOption?.AdditionalArguments,
            _encoderOptions, //[ProcessOptionsEncoder? options = null]
            HandleWorkerStart);


        switch (fileInfo)
        {
            case CompletionStatus.Success:
                Data.Finished = true;
                break;
            case CompletionStatus.Cancelled:
                Data.ResumeFrame += Data.Frame;
                break;
            case CompletionStatus.Failed:
                Data.Started = false;
                Utils.GetInfoBox("FFMpeg Error", _worker == null ? "Unknown Error" : _worker.Output);

                break;
            default:
                Data.Started = false;
                break;
        }
    }

    private void HandleWorkerStart(object sender, ProcessStartedEventArgs e)
    {
        Data.Started = true;
        _worker = (IProcessWorkerEncoder)e.ProcessWorker;
        _worker.ProgressReceived += HandleProgressReceived;
    }

    private void HandleProgressReceived(object sender, ProgressReceivedEventArgs e)
    {
        var s = (IProcessWorkerEncoder)sender;
        Data.TotalFrames = s.FileInfo is FileInfoFFmpeg fi ? fi.FrameCount : 0;
        Data.ProgressBarMax = Data.TotalFrames;
        var progress = (ProgressStatusFFmpeg)e.Progress;
        Data.ProgressBarValue = progress.Frame + Data.ResumeFrame;
        Data.Frame = progress.Frame;
        Data.Fps = progress.Fps;
        Data.Time = progress.Time;
        Data.Bitrate = progress.Bitrate;
        Data.Speed = progress.Speed;
        Data.Status = (((double)Data.ProgressBarValue / Data.ProgressBarMax) * 100).ToString() + "%";

    }

    private void DeleteThisExecute()
    {
        _worker?.Cancel();
        DeleteRequested?.Invoke(this);
    }

    public void Pause()
    {
        DUMMY_TASK = false;
        if (Data.Paused || _worker == null)
        {
            return;
        }

        _worker.Cancel();
    }
    // this is broken because the resume from FFMpeg Library don't works
    private async void PausePlayExecute()
    {
        if (Data.Paused)
        {
            _encoderOptions.ResumePos = Data.ResumeFrame;
            StartExecute();
            PauseText = "Pause";
        }
        else
        {

            Pause();
            if (EncodingTask != null)
            {
                await EncodingTask;
            }
            PauseText = "Continue";
        }

        Data.Paused = !Data.Paused;
    }

    private void CancelThisExecute()
    {
        Pause();
        Data.Started = false;
        _worker = null;
    }


    private bool Validate()
    {
        return (
            !string.IsNullOrEmpty(Data.InputPath)
            && File.Exists(Data.InputPath)
            && !string.IsNullOrEmpty(Data.OutputPath)
            && Utils.TryGetDirectory(Data.InputPath) != null
            && Utils.TryGetDirectory(Data.OutputPath) != null
        );
    }

    private async void ShowOpenFileExecute(string? parameter)
    {
        var filePath = await Utils.OpenFileExplorer();

        if (filePath == null) return;
        switch (parameter)
        {
            case "Output":
                Data.OutputPath = filePath;
                break;
            case "Input":
                Data.InputPath = filePath;
                if (Data.OutputPath == "")
                {
                    Data.OutputPath = Utils.GetAutoOutputPath(filePath);
                }

                break;
        }
    }
}